<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · ClassicalCiphers Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClassicalCiphers Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/master/docs/src/usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.AbstractPair" href="#Main.ClassicalCiphers.AbstractPair"><code>Main.ClassicalCiphers.AbstractPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPair{F, S} = Union{Tuple{F, S}, Pair{F, S}}</code></pre><p>A simple wrapper for a <code>Pair</code>, or a <code>Tuple</code> representing a pair of objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/playfair.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.adjugate-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Integer" href="#Main.ClassicalCiphers.adjugate-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Integer"><code>Main.ClassicalCiphers.adjugate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjugate(mat::AbstractArray{Integer, 2})</code></pre><p>Computes the adjugate matrix for given matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/hill.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.construct_railfence-Tuple{AbstractString, Integer}" href="#Main.ClassicalCiphers.construct_railfence-Tuple{AbstractString, Integer}"><code>Main.ClassicalCiphers.construct_railfence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_railfence(input::AbstractString, n_rails::Integer)
construct_railfence(input::AbstractArray{T}, n_rails::Integer) where {T &lt;: Number}</code></pre><p>See <a href="https://en.wikipedia.org/wiki/Rail_fence_cipher"><code>https://en.wikipedia.org/wiki/Rail_fence_cipher</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; construct_railfence(&quot;WE ARE DISCOVERED. FLEE AT ONCE&quot;, 3)
3×26 Array{Char,2}:
 &#39;W&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;E&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;C&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;R&#39;  …  &#39;□&#39;  &#39;□&#39;  &#39;F&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;A&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;C&#39;  &#39;□&#39;
 &#39;□&#39;  &#39;E&#39;  &#39;□&#39;  &#39;R&#39;  &#39;□&#39;  &#39;D&#39;  &#39;□&#39;  &#39;S&#39;  &#39;□&#39;  &#39;O&#39;  &#39;□&#39;  &#39;E&#39;  &#39;□&#39;     &#39;□&#39;  &#39;.&#39;  &#39;□&#39;  &#39;L&#39;  &#39;□&#39;  &#39;E&#39;  &#39;□&#39;  &#39;T&#39;  &#39;□&#39;  &#39;N&#39;  &#39;□&#39;  &#39;E&#39;
 &#39;□&#39;  &#39;□&#39;  &#39;A&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;I&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;V&#39;  &#39;□&#39;  &#39;□&#39;     &#39;D&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;E&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;  &#39;O&#39;  &#39;□&#39;  &#39;□&#39;  &#39;□&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/railfence.jl#L11-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.crack_affine-Tuple{Any}" href="#Main.ClassicalCiphers.crack_affine-Tuple{Any}"><code>Main.ClassicalCiphers.crack_affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crack_affine(ciphertext; mult::Integer = 0, add::Integer = -1)</code></pre><p>Cracks the given ciphertext according to the Affine cipher. Returns <code>((multiplier, additive constant), decrypted string)</code>.</p><p>Converts the input to lowercase, but retains symbols.</p><p>Optional arguments: <code>mult=0</code>, which specifies the multiplier if known; <code>add=-1</code>, which specifies the additive constant if known.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; crack_affine(&quot;ZQLLU, SUDLN!&quot;)
(&quot;hello, world!&quot;, (3, 4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/affine.jl#L89-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.crack_caesar-Tuple{Any}" href="#Main.ClassicalCiphers.crack_caesar-Tuple{Any}"><code>Main.ClassicalCiphers.crack_caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crack_caesar(ciphertext; cleverness::Integer = 1)</code></pre><p>Cracks the given ciphertext according to the Caesar cipher. Returns <code>(plaintext, key::Integer)</code>, such that <code>encrypt_caesar(plaintext, key)</code> would return ciphertext.</p><p>With <code>cleverness=0</code>, simply does the shift that maximises e&#39;s frequency. With <code>cleverness=1</code>, maximises the string&#39;s total fitness.</p><p>Converts the input to lowercase.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; crack_caesar(&quot;Khoor, Zruog!&quot;)
(&quot;hello, world!&quot;, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/caesar.jl#L64-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.crack_monoalphabetic-Tuple{Any}" href="#Main.ClassicalCiphers.crack_monoalphabetic-Tuple{Any}"><code>Main.ClassicalCiphers.crack_monoalphabetic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crack_monoalphabetic(
    ciphertext;
    starting_key::AbstractString = &quot;&quot;,
    min_temp::AbstractFloat = 0.0001,
    temp_factor::AbstractFloat = 0.97,
    acceptance_prob::AbstractFloat = ((e,ep,t) -&gt; ep &gt; e ? 1. : exp(-(e-ep)/t)),
    chatty::Integer = 0,
    rounds::Integer = 1
)</code></pre><p>crack_monoalphabetic cracks the given ciphertext which was encrypted by the monoalphabetic substitution cipher.</p><p>Returns <code>(the derived key, decrypted plaintext)</code>.</p><p>The various optional arguments to <code>crack_monoalphabetic</code> are:</p><ul><li><code>starting_key=&quot;&quot;</code>, which when specified (for example, as &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;), starts the simulation at the given key. The default causes it to start with the most common characters being decrypted to the most common English characters.</li><li><code>min_temp=0.0001</code>, which is the temperature at which we stop the simulation.</li><li><code>temp_factor=0.97</code>, which is the factor by which the temperature decreases each step.</li><li><code>chatty=0</code>, which can be set to 1 to print whenever the key is updated, or 2 to print whenever any new key is considered (prints to <code>stdout</code>).</li><li><code>rounds=1</code>, which sets the number of repetitions we perform. Each round starts with the best key we&#39;ve found so far.</li><li><code>acceptance_prob=((e, ep, t) -&gt; ep&gt;e ? 1 : exp(-(e-ep)/t))</code>, which is the probability with which we accept new key of fitness ep, given that the current key has fitness e, at temperature t.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; crack_monoalphabetic(str, chatty=0, rounds=10)
(decrypted_string, key)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L264-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.crack_monoalphabetic-Tuple{IO, Any}" href="#Main.ClassicalCiphers.crack_monoalphabetic-Tuple{IO, Any}"><code>Main.ClassicalCiphers.crack_monoalphabetic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crack_monoalphabetic(
    io::IO,
    ciphertext;
    starting_key::AbstractString = &quot;&quot;,
    min_temp::AbstractFloat = 0.0001,
    temp_factor::AbstractFloat = 0.97,
    acceptance_prob::AbstractFloat = ((e,ep,t) -&gt; ep &gt; e ? 1. : exp(-(e-ep)/t)),
    chatty::Integer = 0,
    rounds::Integer = 1
)</code></pre><p>crack_monoalphabetic cracks the given ciphertext which was encrypted by the monoalphabetic substitution cipher.</p><p>Returns <code>(the derived key, decrypted plaintext)</code>.</p><p>The various optional arguments to <code>crack_monoalphabetic</code> are:</p><ul><li><code>starting_key=&quot;&quot;</code>, which when specified (for example, as &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;), starts the simulation at the given key. The default causes it to start with the most common characters being decrypted to the most common English characters.</li><li><code>min_temp=0.0001</code>, which is the temperature at which we stop the simulation.</li><li><code>temp_factor=0.97</code>, which is the factor by which the temperature decreases each step.</li><li><code>chatty=0</code>, which can be set to 1 to print whenever the key is updated, or 2 to print whenever any new key is considered.</li><li><code>rounds=1</code>, which sets the number of repetitions we perform. Each round starts with the best key we&#39;ve found so far.</li><li><code>acceptance_prob=((e, ep, t) -&gt; ep&gt;e ? 1 : exp(-(e-ep)/t))</code>, which is the probability with which we accept new key of fitness ep, given that the current key has fitness e, at temperature t.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; crack_monoalphabetic(str, chatty=0, rounds=10)
(decrypted_string, key)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L132-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.crack_vigenere-Tuple{Any}" href="#Main.ClassicalCiphers.crack_vigenere-Tuple{Any}"><code>Main.ClassicalCiphers.crack_vigenere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crack_vigenere(plaintext; keylength::Integer = 0)</code></pre><p>Cracks the given text encrypted with the Vigenere cipher.</p><p>Returns <code>(derived key, decrypted plaintext)</code>.</p><p>Optional parameters: <code>keylength=0</code>: if the key length is known, specifying it may help the solver. If 0, the solver will attempt to derive the key length using the index of coincidence.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; crack_vigenere(str)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/vigenere.jl#L58-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_affine-Tuple{Any, Integer, Integer}" href="#Main.ClassicalCiphers.decrypt_affine-Tuple{Any, Integer, Integer}"><code>Main.ClassicalCiphers.decrypt_affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_affine(ciphertext, mult::Integer, add::Integer; offset::Integer=0)</code></pre><p>Decrypts the given ciphertext according to the Affine cipher. The key is given as a pair of integers: first the multiplier, then the additive constant.</p><p>The multiplier must be coprime to 26. If it is not, an error is thrown.</p><p>Converts the input to lowercase, but retains symbols.</p><p>Optional argument: <code>offset=0</code>, which specifies what number &#39;a&#39; should be considered as.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_affine(&quot;ZQLLU, SUDLN!&quot;, 3, 4)
&quot;hello, world!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/affine.jl#L35-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_atbash-Tuple{Any, Any}" href="#Main.ClassicalCiphers.decrypt_atbash-Tuple{Any, Any}"><code>Main.ClassicalCiphers.decrypt_atbash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_atbash(ciphertext, alphabet)</code></pre><p>A special case of the substitution cipher, the Atbash cipher substitutes a given alphabet with its reverse:</p><pre><code class="language-julia">decrypt_atbash(ciphertext, &quot;abcdefghijklmnopqrstuvwxyz&quot;) == decrypt_substitution(ciphertext, &quot;zyxwvutsrqponmlkjihgfedcba&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;)
decrypt_atbash(ciphertext, &quot;abcdefghijklmnopqrstuvwxyz&quot;) == decrypt_substitution(ciphertext, &quot;zyxwvutsrqponmlkjihgfedcba&quot;; reverse_dict = true)</code></pre><p><em>Omitting the alphabet, it will assume you are using the English alphabet.</em></p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_atbash(&quot;some text&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;)
&quot;HLNV GVCG&quot;

julia&gt; decrypt_atbash(&quot;HLNV GVCG&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;)
&quot;some text&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L343-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_caesar-Tuple{Any, Integer}" href="#Main.ClassicalCiphers.decrypt_caesar-Tuple{Any, Integer}"><code>Main.ClassicalCiphers.decrypt_caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_caesar(ciphertext, key::Integer)
decrypt_caesar(ciphertext)</code></pre><p>Decrypts the given ciphertext according to the Caesar cipher. The key is given as an integer, being the offset of each character; so <code>decrypt_caesar(&quot;abcd&quot;, 1) == &quot;zabc&quot;</code>.</p><p>Converts the input to lowercase, but retains symbols.</p><p>Traditionally, the Caesar cipher was used with a shift of 3, so this is the method it will fall back to if only given plaintext.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_caesar(&quot;Khoor, Zruog!&quot;, 3)
&quot;hello, world!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/caesar.jl#L33-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_enigma-Tuple" href="#Main.ClassicalCiphers.decrypt_enigma-Tuple"><code>Main.ClassicalCiphers.decrypt_enigma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <code>encrypt_enigma</code> as this function uses identical arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/enigma.jl#L273-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_hill-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T&lt;:Integer" href="#Main.ClassicalCiphers.decrypt_hill-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T&lt;:Integer"><code>Main.ClassicalCiphers.decrypt_hill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_hill(ciphertext, key::AbstractArray{T, 2}) where {T &lt;: Integer}</code></pre><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_hill(&quot;PLHCGQWHRY&quot;, [1 2; 5 7]) # Decrypt the text &quot;PLHCGQWHRY&quot; with key of `[1 2; 5 7]`
&quot;helloworld&quot;

julia&gt; decrypt_hill(&quot;PLHCGQWHRY&quot;, &quot;bcfh&quot;)
&quot;helloworld&quot;

julia&gt; decrypt_hill(&quot;PLHCIX&quot;, &quot;bcfh&quot;) # If the plaintext-length is not a multiple of the dimension of the key matrix, it is padded with X
&quot;hellox&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/hill.jl#L94-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}" href="#Main.ClassicalCiphers.decrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}"><code>Main.ClassicalCiphers.decrypt_monoalphabetic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Arguably the most simple of the classical ciphers, the substitution cipher works by creating an arbitrary substitution dictionary; e.g.,</p><pre><code class="language-julia">&#39;a&#39; =&gt; &#39;x&#39;
&#39;b&#39; =&gt; &#39;g&#39;
&#39;c&#39; =&gt; &#39;l&#39;
...</code></pre><p>This dictionary then replaces every corresponding letter in the plaintext input with a different letter (as specified by the dictionary input.)</p><p>The function <code>decrypt_substitution</code> will either take this dictionary as its second parameter, <em>or</em> it can construct the dictionary itself:</p><pre><code class="language-julia">decrypt_substitution(ciphertext, Dict(...); reverse_dict = true)
decrypt_substitution(ciphertext, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;zyxwvutsrqponmlkjihgfedcba&quot;; reverse_dict = true) # this will create the dictionary &#39;a&#39; =&gt; &#39;z&#39;, &#39;b&#39; =&gt; &#39;y&#39;, ..., &#39;z&#39; =&gt; &#39;a&#39;
decrypt_substitution(ciphertext, &quot;zyxwvutsrqponmlkjihgfedcba&quot;; reverse_dict = true) # this will create the dictionary &#39;a&#39; =&gt; &#39;z&#39;, &#39;b&#39; =&gt; &#39;y&#39;, ..., &#39;z&#39; =&gt; &#39;a&#39; by assuming the keys in the substitution dictionary</code></pre><p><em>All characters undefined in the dictionary are preserved by default; this includes punctionation, spaces, and cases.</em>  This means that, when using a dictionary, strings are not automatically converted into lowercase.</p><p><em>If <code>reverse_dict</code> is set to true (as it is by default), the input dictionary is assumed to be the same used to <em>en</em>crypt, meaning it is reversed in order to <em>decrypt</em> the ciphertext.</em></p><p>As per convention, the output will always be lowercase.</p><p>For more information, see <a href="https://en.wikipedia.org/wiki/Substitution_cipher"><code>https://en.wikipedia.org/wiki/Substitution_cipher</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_monoalphabetic(&quot;ITSSG, ZIOL OL HSQOFZTBZ&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;qwertyuiopasdfghjklzxcvbnm&quot;, reverse_dict = true)
&quot;hello, this is plaintext&quot;

julia&gt; decrypt_monoalphabetic(&quot;Khoor, Zruog!&quot;, &quot;DEFGHIJKLMNOPQRSTUVWXYZABC&quot;)
&quot;hello, world!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L64-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_playfair-Tuple{Any, Matrix{Char}}" href="#Main.ClassicalCiphers.decrypt_playfair-Tuple{Any, Matrix{Char}}"><code>Main.ClassicalCiphers.decrypt_playfair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_playfair(ciphertext, key::Array{Char, 2}; combined::AbstractPair{Char, Char} = (&#39;I&#39;, &#39;J&#39;))</code></pre><p>Decrypts the given ciphertext according to the Playfair cipher.</p><p>Does not attempt to delete X&#39;s inserted as padding for double letters.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_playfair(&quot;RMRMFWYE&quot;, &quot;playfair example&quot;)
&quot;ixixyzax&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/playfair.jl#L163-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_portas-Tuple{Any, AbstractString}" href="#Main.ClassicalCiphers.decrypt_portas-Tuple{Any, AbstractString}"><code>Main.ClassicalCiphers.decrypt_portas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_portas(ciphertext, key::AbstractString)</code></pre><p>Decrypts the given ciphertext with the Portas cipher.</p><p>The key must be given as a string, whose characters are letters.</p><p>Converts the text to lowercase.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_portas(&quot;URYYB, JBEYQ!&quot;, &quot;ab&quot;)
&quot;hello, world!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/portas.jl#L51-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_railfence-Tuple{AbstractString, Integer}" href="#Main.ClassicalCiphers.decrypt_railfence-Tuple{AbstractString, Integer}"><code>Main.ClassicalCiphers.decrypt_railfence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_railfence(input::AbstractString, n_rails::Integer)</code></pre><p>See <a href="https://en.wikipedia.org/wiki/Rail_fence_cipher"><code>https://en.wikipedia.org/wiki/Rail_fence_cipher</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_railfence(&quot;WECRFACERDSOEE.LETNEAIVDEO&quot;, 3)
&quot;wearediscovered.fleeatonce&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/railfence.jl#L60-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T&lt;:Integer" href="#Main.ClassicalCiphers.decrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T&lt;:Integer"><code>Main.ClassicalCiphers.decrypt_solitaire</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_solitaire(string::AbstractString, initialDeck::AbstractVector{T}) where {T &lt;: Integer}</code></pre><p>Decrypts the given ciphertext according to the Solitaire cipher. The key may be given either as a vector initial deck, where the cards are 1 through 54 (the two jokers being 53, 54), or as a string. Schneier&#39;s keying algorithm is used to key the deck if the key is a string.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_solitaire(&quot;EXKYI ZSGEH UNTIQ&quot;, collect(1:54)) # as per https://www.schneier.com/code/sol-test.txt
&quot;aaaaaaaaaaaaaaa&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/solitaire.jl#L118-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.decrypt_vigenere-Tuple{Any, Array}" href="#Main.ClassicalCiphers.decrypt_vigenere-Tuple{Any, Array}"><code>Main.ClassicalCiphers.decrypt_vigenere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decrypt_vigenere(ciphertext, key::Array)
decrypt_vigenere(plaintext, key::AbstractString)</code></pre><p>Decrypts the given string using the Vigenere cipher according to the given vector of offsets. For example, <code>decrypt_vigenere(&quot;ac&quot;, [0, 1])</code> returns <code>&quot;ab&quot;</code>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; decrypt_vigenere(&quot;HFLMOXOSLE&quot;, [0, 1]) # Notice that the offset `0` corresponds to the key `a`.
&quot;helloworld&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/vigenere.jl#L31-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_affine-Tuple{Any, Integer, Integer}" href="#Main.ClassicalCiphers.encrypt_affine-Tuple{Any, Integer, Integer}"><code>Main.ClassicalCiphers.encrypt_affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_affine(plaintext, mult::Integer, add::Integer; offset::Integer = 0)</code></pre><p>Encrypts the given plaintext according to the Affine cipher. The key is given as a pair of integers: first the multiplier, then the additive constant.</p><p>The multiplier must be coprime to 26. If it is not, an error is thrown.</p><p>Converts the input to uppercase, but retains symbols.</p><p>Optional argument: <code>offset=0</code>, which specifies what number &#39;a&#39; should be considered as.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_affine(&quot;Hello, World!&quot;, 3, 4)
&quot;ZQLLU, SUDLN!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/affine.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_atbash-Tuple{Any, Any}" href="#Main.ClassicalCiphers.encrypt_atbash-Tuple{Any, Any}"><code>Main.ClassicalCiphers.encrypt_atbash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_atbash(plaintext, alphabet)</code></pre><p>A special case of the substitution cipher, the Atbash cipher substitutes a given alphabet with its reverse:</p><pre><code class="language-julia">encrypt_atbash(plaintext, &quot;abcdefghijklmnopqrstuvwxyz&quot;) == encrypt_substitution(plaintext, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;zyxwvutsrqponmlkjihgfedcba&quot;)</code></pre><p><em>Omitting the alphabet, it will assume you are using the English alphabet.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L326-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_caesar-Tuple{Any, Integer}" href="#Main.ClassicalCiphers.encrypt_caesar-Tuple{Any, Integer}"><code>Main.ClassicalCiphers.encrypt_caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_caesar(plaintext, key::Integer)
encrypt_caesar(plaintext)</code></pre><p>Encrypts the given plaintext according to the Caesar cipher. The key is given as an integer, being the offset of each character; so <code>encrypt_caesar(&quot;abc&quot;, 1) == &quot;BCD&quot;</code>.</p><p>Converts the input to uppercase, but retains symbols.</p><p>Traditionally, the Caesar cipher was used with a shift of 3, so this is the method it will fall back to if only given plaintext.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_caesar(&quot;Hello, World!&quot;, 3)
&quot;KHOOR, ZRUOG!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/caesar.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_enigma-Union{Tuple{T}, Tuple{Any, Vector{T}, AbstractString}} where T&lt;:Integer" href="#Main.ClassicalCiphers.encrypt_enigma-Union{Tuple{T}, Tuple{Any, Vector{T}, AbstractString}} where T&lt;:Integer"><code>Main.ClassicalCiphers.encrypt_enigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function encrypt_enigma(plaintext,
						rotors::Array{Integer, 1}, key::AbstractString;
						reflector_id=&#39;B&#39;, ring::AbstractString = &quot;AAA&quot;,
						stecker = Tuple{Char, Char}[],
						skip_stecker_check = false)</code></pre><p>Encrypts the given plaintext according to the Enigma (M3, army version).</p><p>Arguments are in the order: <code>plaintext, stecker, rotors, ring, key.</code></p><p>Plaintext is a string; punctuation is stripped out and it is made lowercase. Rotors is an array - for example, <code>[1,2,3]</code> - being the order of the rotors.   Each entry should be a distinct integer between 1 and 5 inclusive. Key is a string of three letters, indicating the starting positions of the rotors.</p><p>Optional:</p><ul><li><code>reflector_id=&#39;B&#39;</code>, which sets whether to use reflector A, B or C.</li></ul><p>Can also be specified as a 26-char string.</p><ul><li>Stecker is either an array - for example,<code>[(&#39;A&#39;,&#39;B&#39;), (&#39;D&#39;, &#39;E&#39;)]</code> specifying</li></ul><p>that A, B are swapped and D, E are swapped - or a string (&quot;ABDE&quot; accomplishing   the same thing). No letter may appear more than once.</p><ul><li>Ring is a string - for example, &quot;AAA&quot; - being the offset applied to each rotor.</li></ul><p>&quot;AAA&quot;, for example, signifies no offset. The string must be three letters.</p><ul><li><code>skip_stecker_check=false</code>, which when <code>true</code> skips validation of stecker settings.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_enigma(&quot;AAA&quot;, [1,2,3], &quot;ABC&quot;)
&quot;CXT&quot;

julia&gt; encrypt_enigma(&quot;AAA&quot;, [1,2,3], &quot;ABC&quot;, ring=&quot;AAA&quot;, reflector_id=&#39;B&#39;, stecker=&quot;&quot;) # synonymous with above
&quot;CXT&quot;

julia&gt; encrypt_enigma(&quot;AAA&quot;, [1,2,3], &quot;ABC&quot;, ring=&quot;AAA&quot;, reflector_id=&quot;YRUHQSLDPXNGOKMIEBFZCWVJAT&quot;, stecker=&quot;&quot;) # synonymous with above
&quot;CXT&quot;

julia&gt; encrypt_enigma(&quot;AAA&quot;, [1,2,3], &quot;ABC&quot;, ring=&quot;AAA&quot;, reflector_id=&#39;B&#39;, stecker=Tuple{Char, Char}[]) # synonymous with above
&quot;CXT&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/enigma.jl#L57-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_hill-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}}} where T&lt;:Integer" href="#Main.ClassicalCiphers.encrypt_hill-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}}} where T&lt;:Integer"><code>Main.ClassicalCiphers.encrypt_hill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_hill(plaintext::AbstractString, key::AbstractArray{Integer, 2})</code></pre><p>Encrypts the given plaintext according to the Hill cipher. The key may be given as a matrix (that is, two-dimensional <code>Array{Int}</code>) or as a string.</p><p>If the key is given as a string, the string is converted to uppercase before use, and symbols are removed. It is assumed to be of square integer length, and the matrix entries are filled top-left to top-right, then next-top left to next-top right, and so on down to bottom-left to bottom-right. If the string is not of square integer length, an error is thrown.</p><p>The matrix must be invertible modulo 26. If it is not, an error is thrown.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_hill(&quot;Hello, World!&quot;, [1 2; 5 7]) # Encrypt the text &quot;Hello, World!&quot; with a Hill key of matrix `[1 2; 5 7]`
&quot;PHHRGUWQRV&quot;

julia&gt; encrypt_hill(&quot;Hello, World!&quot;, &quot;bcfh&quot;)
&quot;PLHCGQWHRY&quot;

julia&gt; encrypt_hill(&quot;Hello&quot;, &quot;bcfh&quot;) # If the plaintext-length is not a multiple of the dimension of the key matrix, it is padded with X
&quot;PLHCIX&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/hill.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}" href="#Main.ClassicalCiphers.encrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}"><code>Main.ClassicalCiphers.encrypt_monoalphabetic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Arguably the most simple of the classical ciphers, the substitution cipher works by creating an arbitrary substitution dictionary; e.g.,</p><pre><code class="language-julia">&#39;a&#39; =&gt; &#39;x&#39;
&#39;b&#39; =&gt; &#39;g&#39;
&#39;c&#39; =&gt; &#39;l&#39;
...</code></pre><p>This dictionary then replaces every corresponding letter in the plaintext input with a different letter (as specified by the dictionary input.)</p><p>The function <code>encrypt_substitution</code> will either take this dictionary as its second parameter, <em>or</em> it can construct the dictionary itself:</p><pre><code class="language-julia">encrypt_substitution(plaintext, Dict(...))
encrypt_substitution(plaintext, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;zyxwvutsrqponmlkjihgfedcba&quot;) # this will create the dictionary &#39;a&#39; =&gt; &#39;z&#39;, &#39;b&#39; =&gt; &#39;y&#39;, ..., &#39;z&#39; =&gt; &#39;a&#39;
encrypt_substitution(plaintext, &quot;zyxwvutsrqponmlkjihgfedcba&quot;) # this will create the dictionary &#39;a&#39; =&gt; &#39;z&#39;, &#39;b&#39; =&gt; &#39;y&#39;, ..., &#39;z&#39; =&gt; &#39;a&#39; by assuming the keys in the substitution dictionary</code></pre><p><em>All characters undefined in the dictionary are preserved by default; this includes punctionation, spaces, and cases.</em>  This means that, when using a dictionary, strings are not automatically converted into uppercase.</p><p>As per convention, the output will always be uppercase.</p><p>For more information, see <a href="https://en.wikipedia.org/wiki/Substitution_cipher"><code>https://en.wikipedia.org/wiki/Substitution_cipher</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_monoalphabetic(&quot;Hello, World!&quot;, &quot;DEFGHIJKLMNOPQRSTUVWXYZABC&quot;)
&quot;KHOOR, ZRUOG!&quot;

julia&gt; encrypt_monoalphabetic(&quot;aBcbDd&quot;, Dict{Char, Char}(&#39;a&#39; =&gt; &#39;5&#39;, &#39;B&#39; =&gt; &#39;@&#39;, &#39;b&#39; =&gt; &#39;o&#39;))
&quot;5@coDd&quot;

julia&gt; encrypt_monoalphabetic(&quot;Hello, this is plaintext&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;qwertyuiopasdfghjklzxcvbnm&quot;)
&quot;ITSSG, ZIOL OL HSQOFZTBZ&quot;

julia&gt; encrypt_monoalphabetic(&quot;Hello, this is plaintext&quot;, &quot;qwertyuiopasdfghjklzxcvbnm&quot;)
&quot;ITSSG, ZIOL OL HSQOFZTBZ&quot;

julia&gt; encrypt_monoalphabetic(&quot;xyz&quot;, Dict(&#39;x&#39; =&gt; &#39;d&#39;, &#39;y&#39; =&gt; &#39;e&#39;, &#39;z&#39; =&gt; &#39;t&#39;))
&quot;det&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L12-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_playfair-Tuple{Any, Matrix{Char}}" href="#Main.ClassicalCiphers.encrypt_playfair-Tuple{Any, Matrix{Char}}"><code>Main.ClassicalCiphers.encrypt_playfair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_playfair(plaintext, key::Array{Char, 2}; stripped::Bool = false, combined::AbstractPair{Char, Char} = (&#39;I&#39;, &#39;J&#39;))</code></pre><p>Encrypts the given plaintext according to the Playfair cipher. Throws an error if the second entry in the <code>combined</code> tuple is present in the key.</p><p>Optional parameters:</p><p><code>stripped=false</code>. When set to true, <code>encrypt_playfair</code> skips   converting the plaintext to uppercase, removing punctuation, and   combining characters which are to be combined in the key. <code>combined=(&#39;I&#39;, &#39;J&#39;)</code>, marks the characters which are to be combined in the text.   Only the first of these two may be present in the output of <code>encrypt_playfair</code>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_playfair(&quot;Hello, World!&quot;, &quot;playfair example&quot;)
&quot;DMYRANVQCRGE&quot;

julia&gt; arr = [&#39;P&#39; &#39;L&#39; &#39;A&#39; &#39;Y&#39; &#39;F&#39;; &#39;I&#39; &#39;R&#39; &#39;E&#39; &#39;X&#39; &#39;M&#39;; &#39;B&#39; &#39;C&#39; &#39;D&#39; &#39;G&#39; &#39;H&#39;; &#39;K&#39; &#39;N&#39; &#39;O&#39; &#39;Q&#39; &#39;S&#39;; &#39;T&#39; &#39;U&#39; &#39;V&#39; &#39;W&#39; &#39;Z&#39;];

julia&gt; encrypt_playfair(&quot;Hello, World!&quot;, arr) # Encrypt the same text using an explicitly specified keysquare
&quot;DMYRANVQCRGE&quot;

julia&gt; encrypt_playfair(&quot;IJXYZA&quot;, &quot;PLAYFIREXM&quot;, combined=(&#39;I&#39;, &#39;J&#39;)) # Optionally specify the two letters which are to be combined (default &#39;I&#39;,&#39;J&#39;)
&quot;RMRMFWYE&quot;

julia&gt; encrypt_playfair(&quot;IJXYZA&quot;, &quot;PLAYFIREXM&quot;, combined=(&#39;X&#39;, &#39;Z&#39;))
&quot;BSGXEY&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/playfair.jl#L46-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_portas-Tuple{Any, AbstractString}" href="#Main.ClassicalCiphers.encrypt_portas-Tuple{Any, AbstractString}"><code>Main.ClassicalCiphers.encrypt_portas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_portas(plaintext, key_in::AbstractString)</code></pre><p>Encrypts the given plaintext with the Portas cipher.</p><p>The key must be given as a string, whose characters are letters.</p><p>Converts the text to uppercase.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_portas(&quot;Hello, World!&quot;, &quot;ab&quot;)
&quot;URYYB, JBEYQ!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/portas.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_railfence-Tuple{AbstractString, Integer}" href="#Main.ClassicalCiphers.encrypt_railfence-Tuple{AbstractString, Integer}"><code>Main.ClassicalCiphers.encrypt_railfence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_railfence(input::AbstractString, n_rails::Integer)</code></pre><p>See <a href="https://en.wikipedia.org/wiki/Rail_fence_cipher"><code>https://en.wikipedia.org/wiki/Rail_fence_cipher</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_railfence(&quot;WE ARE DISCOVERED. FLEE AT ONCE&quot;, 3) # this reads the above matrix row by row
&quot;WECRFACERDSOEE.LETNEAIVDEO&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/railfence.jl#L40-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T&lt;:Integer" href="#Main.ClassicalCiphers.encrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T&lt;:Integer"><code>Main.ClassicalCiphers.encrypt_solitaire</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_solitaire(string::AbstractString, initialDeck::AbstractVector{T}) where {T &lt;: Integer}</code></pre><p>Encrypts the given plaintext according to the Solitaire cipher. The key may be given either as a vector initial deck, where the cards are 1 through 54 (the two jokers being 53, 54), or as a string. Schneier&#39;s keying algorithm is used to key the deck if the key is a string.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_solitaire(&quot;Hello, World!&quot;, &quot;crypto&quot;)
&quot;GRNNQISRYA&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/solitaire.jl#L89-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.encrypt_vigenere-Tuple{Any, Array}" href="#Main.ClassicalCiphers.encrypt_vigenere-Tuple{Any, Array}"><code>Main.ClassicalCiphers.encrypt_vigenere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encrypt_vigenere(plaintext, key::Array)
encrypt_vigenere(ciphertext, key::AbstractString)</code></pre><p>Encrypts the given string using the Vigenere cipher according to the given vector of offsets. For example, <code>encrypt_vigenere(&quot;ab&quot;, [0, 1])</code> returns <code>&quot;AC&quot;</code>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; encrypt_vigenere(&quot;Hello, World!&quot;, &quot;ab&quot;)
&quot;HFLMOXOSLE&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/vigenere.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.frequencies-Tuple{AbstractString}" href="#Main.ClassicalCiphers.frequencies-Tuple{AbstractString}"><code>Main.ClassicalCiphers.frequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frequencies(input::AbstractString)</code></pre><p>Finds the frequencies of all characters in the input string, returning a <code>Dict</code> of <code>&#39;a&#39; =&gt; 4</code>, for instance. Uppercase characters are considered distinct from lowercase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/common.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.index_of_coincidence-Tuple{AbstractString}" href="#Main.ClassicalCiphers.index_of_coincidence-Tuple{AbstractString}"><code>Main.ClassicalCiphers.index_of_coincidence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index_of_coincidence(input::AbstractString)</code></pre><p>Finds the index of coincidence of the input string. Uppercase characters are considered to be equal to their lowercase counterparts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/common.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.playfair_key_to_square-Tuple{AbstractString, Union{Pair{Char, Char}, Tuple{Char, Char}}}" href="#Main.ClassicalCiphers.playfair_key_to_square-Tuple{AbstractString, Union{Pair{Char, Char}, Tuple{Char, Char}}}"><code>Main.ClassicalCiphers.playfair_key_to_square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">playfair_key_to_square(key::AbstractString, replacement::AbstractPair{Char, Char})</code></pre><p>Converts the given key-string to a Playfair key square.</p><p>Parameter <code>replacement</code> is a pair, such as <code>(&#39;I&#39;, &#39;J&#39;)</code> or <code>&#39;I&#39; =&gt; &#39;J&#39;</code>, containing the two letters which are combined. Only the first of these letters will be present in the keysquare.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/playfair.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.string_fitness-Tuple{AbstractString}" href="#Main.ClassicalCiphers.string_fitness-Tuple{AbstractString}"><code>Main.ClassicalCiphers.string_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs a trigram analysis on the input string, to determine how close it is to English. That is, splits the input string into groups of three letters, and assigns a score based on the frequency of the trigrams in true English.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/common.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ClassicalCiphers.swap_two-Tuple{Any}" href="#Main.ClassicalCiphers.swap_two-Tuple{Any}"><code>Main.ClassicalCiphers.swap_two</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_two(str)</code></pre><p>swap_two(string) swaps two of the characters of the input string, at random. The characters are guaranteed to be at different positions, though &quot;aa&quot; would be &#39;swapped&#39; to &quot;aa&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Smaug123/ClassicalCiphers.jl/blob/d1a41bf721e4c318b601260a98f9ff9c881d6672/src/monoalphabetic.jl#L114-L122">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 29 April 2021 22:51">Thursday 29 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
