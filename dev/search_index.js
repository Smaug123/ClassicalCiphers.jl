var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Modules = [ClassicalCiphers]","category":"page"},{"location":"usage/#Main.ClassicalCiphers.AbstractPair","page":"Usage","title":"Main.ClassicalCiphers.AbstractPair","text":"AbstractPair{F, S} = Union{Tuple{F, S}, Pair{F, S}}\n\nA simple wrapper for a Pair, or a Tuple representing a pair of objects.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Main.ClassicalCiphers.adjugate-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.adjugate","text":"adjugate(mat::AbstractArray{Integer, 2})\n\nComputes the adjugate matrix for given matrix.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.construct_railfence-Tuple{AbstractString, Integer}","page":"Usage","title":"Main.ClassicalCiphers.construct_railfence","text":"construct_railfence(input::AbstractString, n_rails::Integer)\nconstruct_railfence(input::AbstractArray{T}, n_rails::Integer) where {T <: Number}\n\nSee https://en.wikipedia.org/wiki/Rail_fence_cipher.\n\n\n\nExamples\n\njulia> construct_railfence(\"WE ARE DISCOVERED. FLEE AT ONCE\", 3)\n3×26 Array{Char,2}:\n 'W'  '□'  '□'  '□'  'E'  '□'  '□'  '□'  'C'  '□'  '□'  '□'  'R'  …  '□'  '□'  'F'  '□'  '□'  '□'  'A'  '□'  '□'  '□'  'C'  '□'\n '□'  'E'  '□'  'R'  '□'  'D'  '□'  'S'  '□'  'O'  '□'  'E'  '□'     '□'  '.'  '□'  'L'  '□'  'E'  '□'  'T'  '□'  'N'  '□'  'E'\n '□'  '□'  'A'  '□'  '□'  '□'  'I'  '□'  '□'  '□'  'V'  '□'  '□'     'D'  '□'  '□'  '□'  'E'  '□'  '□'  '□'  'O'  '□'  '□'  '□'\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.crack_affine-Tuple{Any}","page":"Usage","title":"Main.ClassicalCiphers.crack_affine","text":"crack_affine(ciphertext; mult::Integer = 0, add::Integer = -1)\n\nCracks the given ciphertext according to the Affine cipher. Returns ((multiplier, additive constant), decrypted string).\n\nConverts the input to lowercase, but retains symbols.\n\nOptional arguments: mult=0, which specifies the multiplier if known; add=-1, which specifies the additive constant if known.\n\n\n\nExamples\n\njulia> crack_affine(\"ZQLLU, SUDLN!\")\n(\"hello, world!\", (3, 4))\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.crack_caesar-Tuple{Any}","page":"Usage","title":"Main.ClassicalCiphers.crack_caesar","text":"crack_caesar(ciphertext; cleverness::Integer = 1)\n\nCracks the given ciphertext according to the Caesar cipher. Returns (plaintext, key::Integer), such that encrypt_caesar(plaintext, key) would return ciphertext.\n\nWith cleverness=0, simply does the shift that maximises e's frequency. With cleverness=1, maximises the string's total fitness.\n\nConverts the input to lowercase.\n\n\n\nExamples\n\njulia> crack_caesar(\"Khoor, Zruog!\")\n(\"hello, world!\", 3)\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.crack_monoalphabetic-Tuple{Any}","page":"Usage","title":"Main.ClassicalCiphers.crack_monoalphabetic","text":"crack_monoalphabetic(\n    ciphertext;\n    starting_key::AbstractString = \"\",\n    min_temp::AbstractFloat = 0.0001,\n    temp_factor::AbstractFloat = 0.97,\n    acceptance_prob::AbstractFloat = ((e,ep,t) -> ep > e ? 1. : exp(-(e-ep)/t)),\n    chatty::Integer = 0,\n    rounds::Integer = 1\n)\n\ncrack_monoalphabetic cracks the given ciphertext which was encrypted by the monoalphabetic substitution cipher.\n\nReturns (the derived key, decrypted plaintext).\n\nThe various optional arguments to crack_monoalphabetic are:\n\nstarting_key=\"\", which when specified (for example, as \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), starts the simulation at the given key. The default causes it to start with the most common characters being decrypted to the most common English characters.\nmin_temp=0.0001, which is the temperature at which we stop the simulation.\ntemp_factor=0.97, which is the factor by which the temperature decreases each step.\nchatty=0, which can be set to 1 to print whenever the key is updated, or 2 to print whenever any new key is considered (prints to stdout).\nrounds=1, which sets the number of repetitions we perform. Each round starts with the best key we've found so far.\nacceptance_prob=((e, ep, t) -> ep>e ? 1 : exp(-(e-ep)/t)), which is the probability with which we accept new key of fitness ep, given that the current key has fitness e, at temperature t.\n\n\n\nExamples\n\njulia> crack_monoalphabetic(str, chatty=0, rounds=10)\n(decrypted_string, key)\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.crack_monoalphabetic-Tuple{IO, Any}","page":"Usage","title":"Main.ClassicalCiphers.crack_monoalphabetic","text":"crack_monoalphabetic(\n    io::IO,\n    ciphertext;\n    starting_key::AbstractString = \"\",\n    min_temp::AbstractFloat = 0.0001,\n    temp_factor::AbstractFloat = 0.97,\n    acceptance_prob::AbstractFloat = ((e,ep,t) -> ep > e ? 1. : exp(-(e-ep)/t)),\n    chatty::Integer = 0,\n    rounds::Integer = 1\n)\n\ncrack_monoalphabetic cracks the given ciphertext which was encrypted by the monoalphabetic substitution cipher.\n\nReturns (the derived key, decrypted plaintext).\n\nThe various optional arguments to crack_monoalphabetic are:\n\nstarting_key=\"\", which when specified (for example, as \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), starts the simulation at the given key. The default causes it to start with the most common characters being decrypted to the most common English characters.\nmin_temp=0.0001, which is the temperature at which we stop the simulation.\ntemp_factor=0.97, which is the factor by which the temperature decreases each step.\nchatty=0, which can be set to 1 to print whenever the key is updated, or 2 to print whenever any new key is considered.\nrounds=1, which sets the number of repetitions we perform. Each round starts with the best key we've found so far.\nacceptance_prob=((e, ep, t) -> ep>e ? 1 : exp(-(e-ep)/t)), which is the probability with which we accept new key of fitness ep, given that the current key has fitness e, at temperature t.\n\n\n\nExamples\n\njulia> crack_monoalphabetic(str, chatty=0, rounds=10)\n(decrypted_string, key)\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.crack_vigenere-Tuple{Any}","page":"Usage","title":"Main.ClassicalCiphers.crack_vigenere","text":"crack_vigenere(plaintext; keylength::Integer = 0)\n\nCracks the given text encrypted with the Vigenere cipher.\n\nReturns (derived key, decrypted plaintext).\n\nOptional parameters: keylength=0: if the key length is known, specifying it may help the solver. If 0, the solver will attempt to derive the key length using the index of coincidence.\n\n\n\nExamples\n\njulia> crack_vigenere(str)\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_affine-Tuple{Any, Integer, Integer}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_affine","text":"decrypt_affine(ciphertext, mult::Integer, add::Integer; offset::Integer=0)\n\nDecrypts the given ciphertext according to the Affine cipher. The key is given as a pair of integers: first the multiplier, then the additive constant.\n\nThe multiplier must be coprime to 26. If it is not, an error is thrown.\n\nConverts the input to lowercase, but retains symbols.\n\nOptional argument: offset=0, which specifies what number 'a' should be considered as.\n\n\n\nExamples\n\njulia> decrypt_affine(\"ZQLLU, SUDLN!\", 3, 4)\n\"hello, world!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_atbash-Tuple{Any, Any}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_atbash","text":"decrypt_atbash(ciphertext, alphabet)\n\nA special case of the substitution cipher, the Atbash cipher substitutes a given alphabet with its reverse:\n\ndecrypt_atbash(ciphertext, \"abcdefghijklmnopqrstuvwxyz\") == decrypt_substitution(ciphertext, \"zyxwvutsrqponmlkjihgfedcba\", \"abcdefghijklmnopqrstuvwxyz\")\ndecrypt_atbash(ciphertext, \"abcdefghijklmnopqrstuvwxyz\") == decrypt_substitution(ciphertext, \"zyxwvutsrqponmlkjihgfedcba\"; reverse_dict = true)\n\nOmitting the alphabet, it will assume you are using the English alphabet.\n\n\n\nExamples\n\njulia> encrypt_atbash(\"some text\", \"abcdefghijklmnopqrstuvwxyz\")\n\"HLNV GVCG\"\n\njulia> decrypt_atbash(\"HLNV GVCG\", \"abcdefghijklmnopqrstuvwxyz\")\n\"some text\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_caesar-Tuple{Any, Integer}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_caesar","text":"decrypt_caesar(ciphertext, key::Integer)\ndecrypt_caesar(ciphertext)\n\nDecrypts the given ciphertext according to the Caesar cipher. The key is given as an integer, being the offset of each character; so decrypt_caesar(\"abcd\", 1) == \"zabc\".\n\nConverts the input to lowercase, but retains symbols.\n\nTraditionally, the Caesar cipher was used with a shift of 3, so this is the method it will fall back to if only given plaintext.\n\n\n\nExamples\n\njulia> decrypt_caesar(\"Khoor, Zruog!\", 3)\n\"hello, world!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_enigma-Tuple","page":"Usage","title":"Main.ClassicalCiphers.decrypt_enigma","text":"See encrypt_enigma as this function uses identical arguments.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_hill-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.decrypt_hill","text":"decrypt_hill(ciphertext, key::AbstractArray{T, 2}) where {T <: Integer}\n\n\n\nExamples\n\njulia> decrypt_hill(\"PLHCGQWHRY\", [1 2; 5 7]) # Decrypt the text \"PLHCGQWHRY\" with key of `[1 2; 5 7]`\n\"helloworld\"\n\njulia> decrypt_hill(\"PLHCGQWHRY\", \"bcfh\")\n\"helloworld\"\n\njulia> decrypt_hill(\"PLHCIX\", \"bcfh\") # If the plaintext-length is not a multiple of the dimension of the key matrix, it is padded with X\n\"hellox\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_monoalphabetic","text":"Arguably the most simple of the classical ciphers, the substitution cipher works by creating an arbitrary substitution dictionary; e.g.,\n\n'a' => 'x'\n'b' => 'g'\n'c' => 'l'\n...\n\nThis dictionary then replaces every corresponding letter in the plaintext input with a different letter (as specified by the dictionary input.)\n\nThe function decrypt_substitution will either take this dictionary as its second parameter, or it can construct the dictionary itself:\n\ndecrypt_substitution(ciphertext, Dict(...); reverse_dict = true)\ndecrypt_substitution(ciphertext, \"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\"; reverse_dict = true) # this will create the dictionary 'a' => 'z', 'b' => 'y', ..., 'z' => 'a'\ndecrypt_substitution(ciphertext, \"zyxwvutsrqponmlkjihgfedcba\"; reverse_dict = true) # this will create the dictionary 'a' => 'z', 'b' => 'y', ..., 'z' => 'a' by assuming the keys in the substitution dictionary\n\nAll characters undefined in the dictionary are preserved by default; this includes punctionation, spaces, and cases.  This means that, when using a dictionary, strings are not automatically converted into lowercase.\n\nIf reverse_dict is set to true (as it is by default), the input dictionary is assumed to be the same used to encrypt, meaning it is reversed in order to decrypt the ciphertext.\n\nAs per convention, the output will always be lowercase.\n\nFor more information, see https://en.wikipedia.org/wiki/Substitution_cipher.\n\n\n\nExamples\n\njulia> decrypt_monoalphabetic(\"ITSSG, ZIOL OL HSQOFZTBZ\", \"abcdefghijklmnopqrstuvwxyz\", \"qwertyuiopasdfghjklzxcvbnm\", reverse_dict = true)\n\"hello, this is plaintext\"\n\njulia> decrypt_monoalphabetic(\"Khoor, Zruog!\", \"DEFGHIJKLMNOPQRSTUVWXYZABC\")\n\"hello, world!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_playfair-Tuple{Any, Matrix{Char}}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_playfair","text":"decrypt_playfair(ciphertext, key::Array{Char, 2}; combined::AbstractPair{Char, Char} = ('I', 'J'))\n\nDecrypts the given ciphertext according to the Playfair cipher.\n\nDoes not attempt to delete X's inserted as padding for double letters.\n\n\n\nExamples\n\njulia> decrypt_playfair(\"RMRMFWYE\", \"playfair example\")\n\"ixixyzax\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_portas-Tuple{Any, AbstractString}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_portas","text":"decrypt_portas(ciphertext, key::AbstractString)\n\nDecrypts the given ciphertext with the Portas cipher.\n\nThe key must be given as a string, whose characters are letters.\n\nConverts the text to lowercase.\n\n\n\nExamples\n\njulia> decrypt_portas(\"URYYB, JBEYQ!\", \"ab\")\n\"hello, world!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_railfence-Tuple{AbstractString, Integer}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_railfence","text":"encrypt_railfence(input::AbstractString, n_rails::Integer)\n\nSee https://en.wikipedia.org/wiki/Rail_fence_cipher.\n\n\n\nExamples\n\njulia> decrypt_railfence(\"WECRFACERDSOEE.LETNEAIVDEO\", 3)\n\"wearediscovered.fleeatonce\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.decrypt_solitaire","text":"decrypt_solitaire(string::AbstractString, initialDeck::AbstractVector{T}) where {T <: Integer}\n\nDecrypts the given ciphertext according to the Solitaire cipher. The key may be given either as a vector initial deck, where the cards are 1 through 54 (the two jokers being 53, 54), or as a string. Schneier's keying algorithm is used to key the deck if the key is a string.\n\n\n\nExamples\n\njulia> decrypt_solitaire(\"EXKYI ZSGEH UNTIQ\", collect(1:54)) # as per https://www.schneier.com/code/sol-test.txt\n\"aaaaaaaaaaaaaaa\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.decrypt_vigenere-Tuple{Any, Array}","page":"Usage","title":"Main.ClassicalCiphers.decrypt_vigenere","text":"decrypt_vigenere(ciphertext, key::Array)\ndecrypt_vigenere(plaintext, key::AbstractString)\n\nDecrypts the given string using the Vigenere cipher according to the given vector of offsets. For example, decrypt_vigenere(\"ac\", [0, 1]) returns \"ab\".\n\n\n\nExamples\n\njulia> decrypt_vigenere(\"HFLMOXOSLE\", [0, 1]) # Notice that the offset `0` corresponds to the key `a`.\n\"helloworld\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_affine-Tuple{Any, Integer, Integer}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_affine","text":"encrypt_affine(plaintext, mult::Integer, add::Integer; offset::Integer = 0)\n\nEncrypts the given plaintext according to the Affine cipher. The key is given as a pair of integers: first the multiplier, then the additive constant.\n\nThe multiplier must be coprime to 26. If it is not, an error is thrown.\n\nConverts the input to uppercase, but retains symbols.\n\nOptional argument: offset=0, which specifies what number 'a' should be considered as.\n\n\n\nExamples\n\njulia> encrypt_affine(\"Hello, World!\", 3, 4)\n\"ZQLLU, SUDLN!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_atbash-Tuple{Any, Any}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_atbash","text":"encrypt_atbash(plaintext, alphabet)\n\nA special case of the substitution cipher, the Atbash cipher substitutes a given alphabet with its reverse:\n\nencrypt_atbash(plaintext, \"abcdefghijklmnopqrstuvwxyz\") == encrypt_substitution(plaintext, \"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\")\n\nOmitting the alphabet, it will assume you are using the English alphabet.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_caesar-Tuple{Any, Integer}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_caesar","text":"encrypt_caesar(plaintext, key::Integer)\nencrypt_caesar(plaintext)\n\nEncrypts the given plaintext according to the Caesar cipher. The key is given as an integer, being the offset of each character; so encrypt_caesar(\"abc\", 1) == \"BCD\".\n\nConverts the input to uppercase, but retains symbols.\n\nTraditionally, the Caesar cipher was used with a shift of 3, so this is the method it will fall back to if only given plaintext.\n\n\n\nExamples\n\njulia> encrypt_caesar(\"Hello, World!\", 3)\n\"KHOOR, ZRUOG!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_enigma-Union{Tuple{T}, Tuple{Any, Vector{T}, AbstractString}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.encrypt_enigma","text":"function encrypt_enigma(plaintext,\n\t\t\t\t\t\trotors::Array{Integer, 1}, key::AbstractString;\n\t\t\t\t\t\treflector_id='B', ring::AbstractString = \"AAA\",\n\t\t\t\t\t\tstecker = Tuple{Char, Char}[],\n\t\t\t\t\t\tskip_stecker_check = false)\n\nEncrypts the given plaintext according to the Enigma (M3, army version).\n\nArguments are in the order: plaintext, stecker, rotors, ring, key.\n\nPlaintext is a string; punctuation is stripped out and it is made lowercase. Rotors is an array - for example, [1,2,3] - being the order of the rotors.   Each entry should be a distinct integer between 1 and 5 inclusive. Key is a string of three letters, indicating the starting positions of the rotors.\n\nOptional:\n\nreflector_id='B', which sets whether to use reflector A, B or C.\n\nCan also be specified as a 26-char string.\n\nStecker is either an array - for example,[('A','B'), ('D', 'E')] specifying\n\nthat A, B are swapped and D, E are swapped - or a string (\"ABDE\" accomplishing   the same thing). No letter may appear more than once.\n\nRing is a string - for example, \"AAA\" - being the offset applied to each rotor.\n\n\"AAA\", for example, signifies no offset. The string must be three letters.\n\nskip_stecker_check=false, which when true skips validation of stecker settings.\n\n\n\nExamples\n\njulia> encrypt_enigma(\"AAA\", [1,2,3], \"ABC\")\n\"CXT\"\n\njulia> encrypt_enigma(\"AAA\", [1,2,3], \"ABC\", ring=\"AAA\", reflector_id='B', stecker=\"\") # synonymous with above\n\"CXT\"\n\njulia> encrypt_enigma(\"AAA\", [1,2,3], \"ABC\", ring=\"AAA\", reflector_id=\"YRUHQSLDPXNGOKMIEBFZCWVJAT\", stecker=\"\") # synonymous with above\n\"CXT\"\n\njulia> encrypt_enigma(\"AAA\", [1,2,3], \"ABC\", ring=\"AAA\", reflector_id='B', stecker=Tuple{Char, Char}[]) # synonymous with above\n\"CXT\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_hill-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.encrypt_hill","text":"encrypt_hill(plaintext::AbstractString, key::AbstractArray{Integer, 2})\n\nEncrypts the given plaintext according to the Hill cipher. The key may be given as a matrix (that is, two-dimensional Array{Int}) or as a string.\n\nIf the key is given as a string, the string is converted to uppercase before use, and symbols are removed. It is assumed to be of square integer length, and the matrix entries are filled top-left to top-right, then next-top left to next-top right, and so on down to bottom-left to bottom-right. If the string is not of square integer length, an error is thrown.\n\nThe matrix must be invertible modulo 26. If it is not, an error is thrown.\n\n\n\nExamples\n\njulia> encrypt_hill(\"Hello, World!\", [1 2; 5 7]) # Encrypt the text \"Hello, World!\" with a Hill key of matrix `[1 2; 5 7]`\n\"PHHRGUWQRV\"\n\njulia> encrypt_hill(\"Hello, World!\", \"bcfh\")\n\"PLHCGQWHRY\"\n\njulia> encrypt_hill(\"Hello\", \"bcfh\") # If the plaintext-length is not a multiple of the dimension of the key matrix, it is padded with X\n\"PLHCIX\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_monoalphabetic-Union{Tuple{S}, Tuple{T}, Tuple{Any, Dict{T, S}}} where {T, S}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_monoalphabetic","text":"Arguably the most simple of the classical ciphers, the substitution cipher works by creating an arbitrary substitution dictionary; e.g.,\n\n'a' => 'x'\n'b' => 'g'\n'c' => 'l'\n...\n\nThis dictionary then replaces every corresponding letter in the plaintext input with a different letter (as specified by the dictionary input.)\n\nThe function encrypt_substitution will either take this dictionary as its second parameter, or it can construct the dictionary itself:\n\nencrypt_substitution(plaintext, Dict(...))\nencrypt_substitution(plaintext, \"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\") # this will create the dictionary 'a' => 'z', 'b' => 'y', ..., 'z' => 'a'\nencrypt_substitution(plaintext, \"zyxwvutsrqponmlkjihgfedcba\") # this will create the dictionary 'a' => 'z', 'b' => 'y', ..., 'z' => 'a' by assuming the keys in the substitution dictionary\n\nAll characters undefined in the dictionary are preserved by default; this includes punctionation, spaces, and cases.  This means that, when using a dictionary, strings are not automatically converted into uppercase.\n\nAs per convention, the output will always be uppercase.\n\nFor more information, see https://en.wikipedia.org/wiki/Substitution_cipher.\n\n\n\nExamples\n\njulia> encrypt_monoalphabetic(\"Hello, World!\", \"DEFGHIJKLMNOPQRSTUVWXYZABC\")\n\"KHOOR, ZRUOG!\"\n\njulia> encrypt_monoalphabetic(\"aBcbDd\", Dict{Char, Char}('a' => '5', 'B' => '@', 'b' => 'o'))\n\"5@coDd\"\n\njulia> encrypt_monoalphabetic(\"Hello, this is plaintext\", \"abcdefghijklmnopqrstuvwxyz\", \"qwertyuiopasdfghjklzxcvbnm\")\n\"ITSSG, ZIOL OL HSQOFZTBZ\"\n\njulia> encrypt_monoalphabetic(\"Hello, this is plaintext\", \"qwertyuiopasdfghjklzxcvbnm\")\n\"ITSSG, ZIOL OL HSQOFZTBZ\"\n\njulia> encrypt_monoalphabetic(\"xyz\", Dict('x' => 'd', 'y' => 'e', 'z' => 't'))\n\"det\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_playfair-Tuple{Any, Matrix{Char}}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_playfair","text":"encrypt_playfair(plaintext, key::Array{Char, 2}; stripped::Bool = false, combined::AbstractPair{Char, Char} = ('I', 'J'))\n\nEncrypts the given plaintext according to the Playfair cipher. Throws an error if the second entry in the combined tuple is present in the key.\n\nOptional parameters:\n\nstripped=false. When set to true, encrypt_playfair skips   converting the plaintext to uppercase, removing punctuation, and   combining characters which are to be combined in the key. combined=('I', 'J'), marks the characters which are to be combined in the text.   Only the first of these two may be present in the output of encrypt_playfair.\n\n\n\nExamples\n\njulia> encrypt_playfair(\"Hello, World!\", \"playfair example\")\n\"DMYRANVQCRGE\"\n\njulia> arr = ['P' 'L' 'A' 'Y' 'F'; 'I' 'R' 'E' 'X' 'M'; 'B' 'C' 'D' 'G' 'H'; 'K' 'N' 'O' 'Q' 'S'; 'T' 'U' 'V' 'W' 'Z'];\n\njulia> encrypt_playfair(\"Hello, World!\", arr) # Encrypt the same text using an explicitly specified keysquare\n\"DMYRANVQCRGE\"\n\njulia> encrypt_playfair(\"IJXYZA\", \"PLAYFIREXM\", combined=('I', 'J')) # Optionally specify the two letters which are to be combined (default 'I','J')\n\"RMRMFWYE\"\n\njulia> encrypt_playfair(\"IJXYZA\", \"PLAYFIREXM\", combined=('X', 'Z'))\n\"BSGXEY\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_portas-Tuple{Any, AbstractString}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_portas","text":"encrypt_portas(plaintext, key_in::AbstractString)\n\nEncrypts the given plaintext with the Portas cipher.\n\nThe key must be given as a string, whose characters are letters.\n\nConverts the text to uppercase.\n\n\n\nExamples\n\njulia> encrypt_portas(\"Hello, World!\", \"ab\")\n\"URYYB, JBEYQ!\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_railfence-Tuple{AbstractString, Integer}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_railfence","text":"encrypt_railfence(input::AbstractString, n_rails::Integer)\n\nSee https://en.wikipedia.org/wiki/Rail_fence_cipher.\n\n\n\nExamples\n\njulia> encrypt_railfence(\"WE ARE DISCOVERED. FLEE AT ONCE\", 3) # this reads the above matrix row by row\n\"WECRFACERDSOEE.LETNEAIVDEO\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_solitaire-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}}} where T<:Integer","page":"Usage","title":"Main.ClassicalCiphers.encrypt_solitaire","text":"encrypt_solitaire(string::AbstractString, initialDeck::AbstractVector{T}) where {T <: Integer}\n\nEncrypts the given plaintext according to the Solitaire cipher. The key may be given either as a vector initial deck, where the cards are 1 through 54 (the two jokers being 53, 54), or as a string. Schneier's keying algorithm is used to key the deck if the key is a string.\n\n\n\nExamples\n\njulia> encrypt_solitaire(\"Hello, World!\", \"crypto\")\n\"GRNNQISRYA\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.encrypt_vigenere-Tuple{Any, Array}","page":"Usage","title":"Main.ClassicalCiphers.encrypt_vigenere","text":"encrypt_vigenere(plaintext, key::Array)\nencrypt_vigenere(ciphertext, key::AbstractString)\n\nEncrypts the given string using the Vigenere cipher according to the given vector of offsets. For example, encrypt_vigenere(\"ab\", [0, 1]) returns \"AC\".\n\n\n\nExamples\n\njulia> encrypt_vigenere(\"Hello, World!\", \"ab\")\n\"HFLMOXOSLE\"\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.frequencies-Tuple{AbstractString}","page":"Usage","title":"Main.ClassicalCiphers.frequencies","text":"frequencies(input::AbstractString)\n\nFinds the frequencies of all characters in the input string, returning a Dict of 'a' => 4, for instance. Uppercase characters are considered distinct from lowercase.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.index_of_coincidence-Tuple{AbstractString}","page":"Usage","title":"Main.ClassicalCiphers.index_of_coincidence","text":"index_of_coincidence(input::AbstractString)\n\nFinds the index of coincidence of the input string. Uppercase characters are considered to be equal to their lowercase counterparts.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.playfair_key_to_square-Tuple{AbstractString, Union{Pair{Char, Char}, Tuple{Char, Char}}}","page":"Usage","title":"Main.ClassicalCiphers.playfair_key_to_square","text":"playfair_key_to_square(key::AbstractString, replacement::AbstractPair{Char, Char})\n\nConverts the given key-string to a Playfair key square.\n\nParameter replacement is a pair, such as ('I', 'J') or 'I' => 'J', containing the two letters which are combined. Only the first of these letters will be present in the keysquare.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.string_fitness-Tuple{AbstractString}","page":"Usage","title":"Main.ClassicalCiphers.string_fitness","text":"Performs a trigram analysis on the input string, to determine how close it is to English. That is, splits the input string into groups of three letters, and assigns a score based on the frequency of the trigrams in true English.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Main.ClassicalCiphers.swap_two-Tuple{Any}","page":"Usage","title":"Main.ClassicalCiphers.swap_two","text":"swap_two(str)\n\nswap_two(string) swaps two of the characters of the input string, at random. The characters are guaranteed to be at different positions, though \"aa\" would be 'swapped' to \"aa\".\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides access to encryption and decryption of strings according to a variety of classical algorithms.  Classical ciphers were created before computers, and thus work on letters rather than bits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Solitaire cipher is included for completeness, though it is perhaps not strictly classical.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently implemented ciphers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Caesar\nAffine\nMonoalphabetic substitution\nVigenère\nPortas\nHill\nPlayfair\nEnigma (M3 Army)\nSolitaire\nRail Fence\nAtbash","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClassicalCiphers\nDocTestSetup = quote\n    using ClassicalCiphers\nend","category":"page"},{"location":"#Installing-ClassicalCiphers.jl","page":"Home","title":"Installing ClassicalCiphers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ClassicalCiphers\")","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
